/*==============================================================================
 * FILE: join_bin.c
 *
 * PURPOSE: Joins together multiple .bin files generated by an MPI job into one
 *   file for visualization and analysis.  The code is not optimal and can be
 *   a memory hog, as it loads all data into memory before writing out the 
 *   joined file.
 *
 * COMPILE USING: gcc -Wall -W -o join_bin join_bin.c -lm
 *
 * USAGE: ./join_bin -o <outfile.bin> infile1.bin infile2.bin ...
 *
 * WRITTEN BY: Aaron Skinner after Tom Gardiner, November 2004
 *============================================================================*/

#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <assert.h>

/* For now, this must be set by hand...  */
// typedef float  Real;
typedef double Real;

static void join_error(const char *fmt, ...);
static void init_domain_1d(void);
static void chek_domain_3d(void);
static void sort_domain_1d(void);
static void write_joined_bin(const char *out_name);
static char *my_strdup(const char *in);
static void free_3d_array(void ***array);
static void*** calloc_3d_array(size_t nt, size_t nr, size_t nc, size_t size);


/* This stores the domain information of each .bin file */
typedef struct Domain_s{
  char *fname;
  FILE *fp;
  enum COORD_SYS {cartesian=-1,cylindrical=-2,spherical=-3} coord_sys;
  int Nx, Ny, Nz;    /* Grid dimensions */
  int Nvar,Nscalars;
  enum BOOLEAN {false,true} self_gravity, particles;
  Real gamma_1, iso_csound, time, dt;
  Real *xcoords,*ycoords,*zcoords;
}BIN_Domain;


static int file_count; /* Number of input .bin files */
static BIN_Domain *domain_1d;

/* NGrid_{x,y,z} -> Number of grids in x-, y- and z-direction */
static int NGrid_x, NGrid_y, NGrid_z;
static BIN_Domain ***domain_3d=NULL;


/* ========================================================================== */


int main(int argc, char* argv[]){

  int i, j, k, n;
  char *out_name=NULL;

  if(argc < 5)
    join_error("Usage: %s -o <out_name.bin> file1.bin file2.bin ...\n",argv[0]);

  file_count = argc-3; /* Number of input .bin files */

  /* Parse the command line for the output filename */
  for(i=1; i<argc-1; i++){
    if(strcmp(argv[i],"-o") == 0){
      i++; /* increment to the filename */
      if((out_name = my_strdup(argv[i])) == NULL)
	join_error("[main]:  out_name = my_strdup(\"%s\") failed\n",argv[i]);
      break;
    }
  }

  /* An output filename is required */
  if(out_name == NULL)
    join_error("Usage: %s -o <out_name.bin> file1.bin file2.bin ...\n",argv[0]);

  printf("Output filename is \"%s\"\n",out_name);
  printf("Found %d files on the command line\n",file_count);

  /* ====================================================================== */

  domain_1d = (BIN_Domain*)calloc(file_count,sizeof(BIN_Domain));
  if(domain_1d == NULL)
    join_error("[main]:  calloc returned a NULL pointer for domain_1d\n");

  /* Populate the 1d domain array with the filenames */
  for(n=0, i=1; i<argc; i++){
    if(strcmp(argv[i],"-o") == 0){
      i++; /* increment to the filename */
    }
    else{
      if((domain_1d[n].fname = my_strdup(argv[i])) == NULL){
	join_error("[main]:  domain_1d[%d].fname = my_strdup(\"%s\") failed\n",
		   n,argv[i]);
      }
      //printf("domain_1d[%d].fname = \"%s\"\n",n,domain_1d[n].fname);
      n++; /* increment the domain counter */
    }
  }

  init_domain_1d(); /* Read in the header information */

  sort_domain_1d(); /* Sort the BIN_Domain elements in [k][j][i] order */

  /* Allocate the domain_3d[][][] array */
  domain_3d = (BIN_Domain***)
    calloc_3d_array(NGrid_z, NGrid_y, NGrid_x, sizeof(BIN_Domain));
  if(domain_3d == NULL)
    join_error("[main]:  calloc_3d_array() returned a NULL pointer\n");

  /* Copy the contents of the domain_1d[] array to the domain_3d[][][] array */
  n=0;
  for(k=0; k<NGrid_z; k++){
    for(j=0; j<NGrid_y; j++){
      for(i=0; i<NGrid_x; i++){
	domain_3d[k][j][i] = domain_1d[n++];
      }
    }
  }

  chek_domain_3d();  /* Check the domains for consistency */

  /* To make this code more bulletproof, add a call to some function to
     check that this domain array satisfies a set of consistency
     conditions like nx is constant along y- and z-directions, etc. */

  /* ====================================================================== */

  write_joined_bin(out_name);

  /* ====================================================================== */

  /* Now we need to do some cleanup */
  free_3d_array((void ***)domain_3d);
  domain_3d = NULL;

  /* Now close the input files and free the input file names */
  for(i=0; i<file_count; i++){
    fclose(domain_1d[i].fp);
    free(domain_1d[i].fname);
    domain_1d[i].fname = NULL;

    free(domain_1d[i].xcoords);
    domain_1d[i].xcoords = NULL;
    free(domain_1d[i].ycoords);
    domain_1d[i].ycoords = NULL;
    free(domain_1d[i].zcoords);
    domain_1d[i].zcoords = NULL;
  }

  free(domain_1d);
  domain_1d = NULL;

  free(out_name);
  out_name = NULL;

  return(0) ;
}

/* ========================================================================== */


/* Write an error message and terminate the simulation with an error status. */
static void join_error(const char *fmt, ...){
  va_list ap;

  va_start(ap, fmt);         /* ap starts after the fmt parameter */
  vfprintf(stderr, fmt, ap); /* print the error message to stderr */
  va_end(ap);                /* end stdargs (clean up the va_list ap) */

  fflush(stderr);            /* flush it NOW */
  exit(1);                   /* clean up and exit */
}


/* ========================================================================== */


/* Input character pointer is to the start of a NUL terminated string */
static void strip_trail_white(char *pc){
  char *cp = pc;

  /* iterate down to the NUL terminator */
  while(*cp != '\0') cp++;

  while(cp > pc){
    cp--;
    if(isspace(*cp)) *cp = '\0';
    else break;
  }

  return;
}


static void init_domain_1d(void){
  FILE *fp=NULL;              /* A temporary copy to make the code cleaner */
  int coord_sys, Nx, Ny, Nz;  /* Temporary copies to make the code cleaner */
  int i, idat[7];
  Real fdat[4];

  for(i=0; i<file_count; i++){
    /* Open file for reading */
    if((fp = domain_1d[i].fp = fopen(domain_1d[i].fname,"rb")) == NULL)
      join_error("[init_domain_1d]:  Error opening file \"%s\"\n",domain_1d[i].fname);

    printf("domain_1d[%d].fname = \"%s\"\n",i,domain_1d[i].fname);

    /* Get coordinate system */
    fread(&domain_1d[i].coord_sys,sizeof(int),1,fp);
    coord_sys = domain_1d[i].coord_sys;
    if((coord_sys != cartesian) && (coord_sys != cylindrical) && (coord_sys != spherical))
      join_error("[init_domain_1d]:  Coordinate system \"%d\" is not supported!\n",coord_sys);

    /* Get number of zones and variables */
    fread(idat,sizeof(int),7,fp);
    Nx = domain_1d[i].Nx      = idat[0];
    Ny = domain_1d[i].Ny      = idat[1];
    Nz = domain_1d[i].Nz      = idat[2];
    domain_1d[i].Nvar         = idat[3];
    domain_1d[i].Nscalars     = idat[4];
    domain_1d[i].self_gravity = idat[5];
    domain_1d[i].particles    = idat[6];

    /* Get (gamma-1), isothermal sound speed, time, dt */
    fread(fdat,sizeof(Real),4,fp);
    domain_1d[i].gamma_1    = fdat[0];
    domain_1d[i].iso_csound = fdat[1];
    domain_1d[i].time       = fdat[2];
    domain_1d[i].dt         = fdat[3];

    /* From here on, I assume the header is OK! */

    /* Allocate temporary storage */
    if((domain_1d[i].xcoords = (Real *)malloc(Nx*sizeof(Real))) == NULL) {
      join_error("[init_domain_1d]: malloc failed for temporary xcoords array\n");
      return;
    }
    if((domain_1d[i].ycoords = (Real *)malloc(Ny*sizeof(Real))) == NULL) {
      join_error("[init_domain_1d]: malloc failed for temporary ycoords array\n");
      return;
    }
    if((domain_1d[i].zcoords = (Real *)malloc(Nz*sizeof(Real))) == NULL) {
      join_error("[init_domain_1d]: malloc failed for temporary zcoords array\n");
      return;
    }

    /* Read in coordinate data */
    fread(domain_1d[i].xcoords,sizeof(Real),Nx,fp);
    fread(domain_1d[i].ycoords,sizeof(Real),Ny,fp);
    fread(domain_1d[i].zcoords,sizeof(Real),Nz,fp);
  }

  return;
}


static void chek_domain_3d(void){
  int i,j,k;
  int warn_flag = 0;

  for(k=0; k<NGrid_z; k++){
    for(j=0; j<NGrid_y; j++){
      for(i=0; i<NGrid_x; i++){
//         warn_flag = warn_flag && (ftell(domain_3d[k][j][i].fp)    == ftell(domain_3d[0][0][0].fp)   );
        warn_flag = warn_flag && (domain_3d[k][j][i].coord_sys    == domain_3d[0][0][0].coord_sys   );
        warn_flag = warn_flag && (domain_3d[k][j][i].Nvar         == domain_3d[0][0][0].Nvar        );
        warn_flag = warn_flag && (domain_3d[k][j][i].Nscalars     == domain_3d[0][0][0].Nscalars    );
        warn_flag = warn_flag && (domain_3d[k][j][i].self_gravity == domain_3d[0][0][0].self_gravity);
        warn_flag = warn_flag && (domain_3d[k][j][i].particles    == domain_3d[0][0][0].particles   );
        warn_flag = warn_flag && (domain_3d[k][j][i].gamma_1      == domain_3d[0][0][0].gamma_1     );
        warn_flag = warn_flag && (domain_3d[k][j][i].iso_csound   == domain_3d[0][0][0].iso_csound  );
        warn_flag = warn_flag && (domain_3d[k][j][i].time         == domain_3d[0][0][0].time        );
        warn_flag = warn_flag && (domain_3d[k][j][i].dt           == domain_3d[0][0][0].dt          );
      }
    }
  }

  if (warn_flag)
    join_error("[chek_domain_3d]:  These file pieces are not self-consistent!\n");
  else
    printf("CONSISTENCY CHECK PASSED!\n");

  return;
}



/* ========================================================================== */


static int compare_xmin(const void *p1, const void *p2){

  if(((BIN_Domain*)p1)->xcoords[0] < ((BIN_Domain*)p2)->xcoords[0]) return -1;
  else if(((BIN_Domain*)p1)->xcoords[0] > ((BIN_Domain*)p2)->xcoords[0]) return 1;
  else return 0;
}


static int compare_ymin(const void *p1, const void *p2){

  if(((BIN_Domain*)p1)->ycoords[0] < ((BIN_Domain*)p2)->ycoords[0]) return -1;
  else if(((BIN_Domain*)p1)->ycoords[0] > ((BIN_Domain*)p2)->ycoords[0]) return 1;
  else return 0;
}


static int compare_zmin(const void *p1, const void *p2){

  if(((BIN_Domain*)p1)->zcoords[0] < ((BIN_Domain*)p2)->zcoords[0]) return -1;
  else if(((BIN_Domain*)p1)->zcoords[0] > ((BIN_Domain*)p2)->zcoords[0]) return 1;
  else return 0;
}


static void sort_domain_1d(void){
  int i, j, xcount, ycount, zcount, xy_cnt, yz_cnt;
  Real ymin, zmin;
  div_t cnt_div;

  /* Sort the domains in ascending order of the z-min in each domain */
  qsort(domain_1d, file_count, sizeof(BIN_Domain), compare_zmin);

  /* Now count the number of Grid domains in the z-direction */
  zmin = domain_1d[0].zcoords[0];
  zcount=1;
//  printf("zcount = 1 @ zmin = %e\n",zmin);
  for(i=1; i<file_count; i++){
    if(domain_1d[i].zcoords[0] > zmin){
      zmin = domain_1d[i].zcoords[0];
      zcount++;
//      printf("zcount = %d @ zmin = %e\n",zcount,zmin);
    }
  }

  cnt_div = div(file_count, zcount);

  if(cnt_div.rem != 0)
    join_error("[sort_domain_1d]:  file_count%%zcount = %d\n",cnt_div.rem);

  xy_cnt = cnt_div.quot;

  /* Sort each group of domains with the same Z-MIN in order of
     ascending Y-MIN. */
  for(i=0; i<zcount; i++){
    qsort(&(domain_1d[i*xy_cnt]), xy_cnt, sizeof(BIN_Domain), compare_ymin);

    /* Count the number of grid domains in the y-direction */
    if(i == 0){
      ymin = domain_1d[0].ycoords[0];
      ycount=1;
//      printf("ycount = 1 @ ymin = %e\n",ymin);
      for(j=1; j<xy_cnt; j++){
	if(domain_1d[j].ycoords[0] > ymin){
	  ymin = domain_1d[j].ycoords[0];
	  ycount++;
// 	  printf("ycount = %d @ ymin = %e\n",ycount,ymin);
	}
      }
    }
    /* For i != 0 we will make sure this is uniformly consistent later */
  }

  cnt_div = div(xy_cnt, ycount);

  if(cnt_div.rem != 0)
    join_error("[sort_domain_1d]:  xy_cnt%%ycount = %d\n",cnt_div.rem);

  xcount = cnt_div.quot;
//  printf("xcount = %d\n",xcount);
  yz_cnt = ycount*zcount;

  /* Sort each group of domains with the same Y-MIN and Z-MIN in order of
     ascending X-MIN. */
  for(i=0; i<yz_cnt; i++){
    qsort(&(domain_1d[i*xcount]), xcount, sizeof(BIN_Domain), compare_xmin);
  }

  /* For debugging purposes, write out the origin for all of the grid
     domains in what should now be an ascending order for a [k][j][i] array. */
  /* for(i=0; i<file_count; i++){
     printf("[%d]: xmin=%f  ymin=%f  zmin=%f\n",i,
     domain_1d[i].xcoords[0], domain_1d[i].ycoords[0], domain_1d[i].zcoords[0]);
     } */

  /* Initialize NGrid_{x,y,z} */
  NGrid_x = xcount;
  NGrid_y = ycount;
  NGrid_z = zcount;
printf("NGrid_x = %d, NGrid_y = %d, NGrid_z = %d\n", NGrid_x, NGrid_y, NGrid_z);

  return;
}


/* ========================================================================== */


static void write_joined_bin(const char *out_name){
  FILE *fp_out, *fp_in;
  int nxt, nyt, nzt;  /* Total number of grid cells in each dir. */
  int idat[7];        /* Integer data for header */
  Real fdat[4];      /* Real data for the header */
  int i,j,k,n,ig,jg,kg,nread;
  BIN_Domain *pD = &domain_3d[0][0][0];  /* to make the code cleaner */

  /* Count the total number of grid cells in each direction */
  nxt = nyt = nzt = 0;
  for(i=0; i<NGrid_x; i++)
    nxt += domain_3d[0][0][i].Nx;

  for(j=0; j<NGrid_y; j++)
    nyt += domain_3d[0][j][0].Ny;

  for(k=0; k<NGrid_z; k++)
    nzt += domain_3d[k][0][0].Nz;

  printf("nxt = %d, nyt = %d, nzt = %d\n", nxt,nyt,nzt);

  /* Open the output file */
  if((fp_out = fopen(out_name,"wb")) == NULL)
    join_error("[write_joined_bin]:  Error opening the output file \"%s\"\n",out_name);

  /* Write the coordinate system information */
  fwrite(&pD->coord_sys,sizeof(int),1,fp_out);

  /* Write number of zones and variables */
  idat[0] = nxt;
  idat[1] = nyt;
  idat[2] = nzt;
  idat[3] = pD->Nvar;
  idat[4] = pD->Nscalars;
  idat[5] = pD->self_gravity;
  idat[6] = pD->particles;
  fwrite(idat,sizeof(int),7,fp_out);

  /* Write (gamma-1), isothermal sound speed, time, dt */
  fdat[0] = pD->gamma_1;
  fdat[1] = pD->iso_csound;
  fdat[2] = pD->time;
  fdat[3] = pD->dt;
  fwrite(fdat,sizeof(Real),4,fp_out);

  /* Read/write coordinate data */
  for(ig=0; ig<NGrid_x; ig++){
    fwrite(domain_3d[0][0][ig].xcoords,sizeof(Real),domain_3d[0][0][ig].Nx,fp_out);
  }
  for(jg=0; jg<NGrid_y; jg++){
    fwrite(domain_3d[0][jg][0].ycoords,sizeof(Real),domain_3d[0][jg][0].Ny,fp_out);
  }
  for(kg=0; kg<NGrid_z; kg++){
    fwrite(domain_3d[kg][0][0].zcoords,sizeof(Real),domain_3d[kg][0][0].Nz,fp_out);
  }

  /* Read/write 3D scalar data */
  for (n=0; n<pD->Nvar; n++) {
    printf("Reading variable %d\n", n);
    for(kg=0; kg<NGrid_z; kg++){
      for(k=0; k<domain_3d[kg][0][0].Nz; k++){
        for(jg=0; jg<NGrid_y; jg++){
          for(j=0; j<domain_3d[0][jg][0].Ny; j++){
            for(ig=0; ig<NGrid_x; ig++){
              for(i=0; i<domain_3d[0][0][ig].Nx; i++){
                fp_in = domain_3d[kg][jg][ig].fp;

                if((nread = fread(&fdat, sizeof(Real), 1, fp_in)) != 1)
                  join_error("[read_write_scalar]:  read error\n");

                fwrite(&fdat, sizeof(Real), 1, fp_out);
              }
            }
          }
        }
      }
    }
  }

  fclose(fp_out);
  return;
}


/* ========================================================================== */


static char *my_strdup(const char *in){
  char *out = (char *)malloc((1+strlen(in))*sizeof(char));
  if(out == NULL) {
    fprintf(stderr,"[my_strdup]: failed to allocate %d\n",(1+strlen(in)));
    return NULL; /* malloc failed */
  }
  return strcpy(out,in);
}


/* ========================================================================== */


/* Free the 3-D array: array[nt][nr][nc]
   Usage: free_2d_array((void ***)array);
*/
static void free_3d_array(void ***array){

  free(array[0][0]);
  free(array[0]);
  free(array);
}


/* Construct a 3-D array: array[nt][nr][nc] 
   Usage: array = (Real ***)calloc_3d_array(nt,nr,nc,sizeof(Real));
*/
static void*** calloc_3d_array(size_t nt, size_t nr, size_t nc, size_t size){

  void ***array;
  size_t i,j;

  if((array = (void ***)calloc(nt,sizeof(void**))) == NULL){
    fprintf(stderr,"[calloc_3d_array]:  failed calloc 1(%d)",nt);
    return NULL;
  }

  if((array[0] = (void **)calloc(nt*nr,sizeof(void*))) == NULL){
    fprintf(stderr,"[calloc_3d_array]:  failed calloc 2(%d)",nt*nr);
    free((void *)array);
    return NULL;
  }

  for(i=1; i<nt; i++){
    array[i] = (void **)((unsigned char *)array[0] + i*nr*sizeof(void*));
  }

  if((array[0][0] = (void *)calloc(nt*nr*nc,size)) == NULL){
    fprintf(stderr,"[calloc_3d_array]:  failed calloc_3d(%d,%d,%d,%d)",nt,nr,nr,size);
    free((void *)array[0]);
    free((void *)array);
    return NULL;
  }

  for(j=1; j<nr; j++){
    array[0][j] = (void **)((unsigned char *)array[0][j-1] + nc*size);
  }

  for(i=1; i<nt; i++){
    array[i][0] = (void **)((unsigned char *)array[i-1][0] + nr*nc*size);
    for(j=1; j<nr; j++){
      array[i][j] = (void **)((unsigned char *)array[i][j-1] + nc*size);
    }
  }

  return array;
}


/* ========================================================================== */
